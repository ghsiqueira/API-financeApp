// routes/transactions.js - SISTEMA MOCKADO INDEPENDENTE (como budgets)
const express = require('express')
const router = express.Router()
const { body, validationResult } = require('express-validator')
const jwt = require('jsonwebtoken')

// Mock de transa√ß√µes (similar ao sistema de or√ßamentos)
let transactions = [
  {
    _id: '1',
    userId: '1754097538803.4392', // Mesmo userId do JWT
    tipo: 'despesa',
    descricao: 'Almo√ßo',
    valor: 25.50,
    categoria: '1',
    metodoPagamento: 'cartao_debito',
    data: new Date(),
    observacoes: 'Teste inicial',
    orcamentoId: '',
    tags: [],
    recorrente: {
      ativo: false,
      tipo: 'mensal',
      dataInicio: new Date(),
      dataFim: new Date(),
      intervalo: 1
    },
    criadoEm: new Date(),
    atualizadoEm: new Date()
  }
]

// Mock de usu√°rios (mesmo que est√° funcionando nos or√ßamentos)
const mockUsers = [
  {
    _id: '1',
    nome: 'Gabriel',
    email: 'admin@financeapp.com',
    senhaHash: '$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj1VpJUjJC3a'
  },
  {
    _id: '1754097538803.4392',
    nome: 'Teste',
    email: 'teste@teste.com',
    senhaHash: '$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj1VpJUjJC3a'
  }
]

// üî• FUN√á√ÉO PARA CRIAR USU√ÅRIO AUTOMATICAMENTE
const createUserIfNotExists = (userId, email) => {
  let user = mockUsers.find(u => u._id === userId || u._id.toString() === userId)
  
  if (!user) {
    console.log('üÜï [TRANSACTIONS] Criando usu√°rio automaticamente:', { userId, email })
    
    const newUser = {
      _id: userId,
      nome: email ? email.split('@')[0] : 'Usu√°rio',
      email: email || `user${userId}@app.com`,
      senhaHash: '$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj1VpJUjJC3a'
    }
    
    mockUsers.push(newUser)
    user = newUser
    
    console.log('‚úÖ [TRANSACTIONS] Usu√°rio criado automaticamente')
  }
  
  return user
}

// üî• MIDDLEWARE DE AUTENTICA√á√ÉO INDEPENDENTE (n√£o depende de outros arquivos)
const transactionsAuth = (req, res, next) => {
  console.log('üîê [TRANSACTIONS] Auth middleware iniciado')
  
  try {
    // Extrair token do header Authorization
    const authHeader = req.headers['authorization']
    const token = authHeader && authHeader.startsWith('Bearer ') 
      ? authHeader.substring(7) 
      : authHeader

    if (!token) {
      console.log('‚ùå [TRANSACTIONS] Token n√£o fornecido')
      return res.status(401).json({ 
        error: 'Token de acesso n√£o fornecido',
        code: 'NO_TOKEN'
      })
    }

    // Verificar e decodificar token
    let decoded
    try {
      decoded = jwt.verify(token, process.env.JWT_SECRET)
      console.log('üîç [TRANSACTIONS] JWT decoded:', { userId: decoded.userId, email: decoded.email })
    } catch (err) {
      console.log('‚ùå [TRANSACTIONS] Erro na verifica√ß√£o do token:', err.message)
      if (err.name === 'TokenExpiredError') {
        return res.status(401).json({ 
          error: 'Token expirado',
          code: 'TOKEN_EXPIRED'
        })
      } else {
        return res.status(401).json({ 
          error: 'Token inv√°lido',
          code: 'INVALID_TOKEN'
        })
      }
    }

    // Extrair dados do token
    const userIdFromToken = decoded.userId || decoded.id
    const emailFromToken = decoded.email
    console.log('üë§ [TRANSACTIONS] Buscando usu√°rio com ID:', userIdFromToken)

    if (!userIdFromToken) {
      return res.status(401).json({ 
        error: 'ID do usu√°rio n√£o encontrado no token',
        code: 'NO_USER_ID_IN_TOKEN'
      })
    }

    // üî• BUSCAR USU√ÅRIO NO SISTEMA MOCKADO
    let user = mockUsers.find(u => u._id === userIdFromToken || u._id.toString() === userIdFromToken)
    
    if (!user) {
      console.log('‚ùå [TRANSACTIONS] Usu√°rio n√£o encontrado, criando automaticamente')
      user = createUserIfNotExists(userIdFromToken, emailFromToken)
    }

    if (!user) {
      console.log('‚ùå [TRANSACTIONS] Falha ao criar/encontrar usu√°rio')
      return res.status(401).json({ 
        error: 'Usu√°rio n√£o encontrado',
        code: 'USER_NOT_FOUND'
      })
    }

    // Adicionar informa√ß√µes do usu√°rio √† requisi√ß√£o
    req.userId = user._id
    req.user = user

    console.log('‚úÖ [TRANSACTIONS] Autentica√ß√£o bem-sucedida para:', user.email)
    next()

  } catch (err) {
    console.error('‚ùå [TRANSACTIONS] Erro no middleware de autentica√ß√£o:', err)
    res.status(500).json({ 
      error: 'Erro interno do servidor',
      code: 'INTERNAL_ERROR'
    })
  }
}

// Aplicar auth em todas as rotas
router.use(transactionsAuth)

// Valida√ß√µes
const transactionValidation = [
  body('tipo')
    .isIn(['receita', 'despesa'])
    .withMessage('Tipo deve ser receita ou despesa'),
  
  body('descricao')
    .trim()
    .isLength({ min: 1, max: 200 })
    .withMessage('Descri√ß√£o deve ter entre 1 e 200 caracteres'),
  
  body('valor')
    .isNumeric()
    .custom(value => {
      if (parseFloat(value) <= 0) {
        throw new Error('Valor deve ser maior que 0')
      }
      return true
    }),
  
  body('categoria')
    .trim()
    .isLength({ min: 1 })
    .withMessage('Categoria √© obrigat√≥ria'),
  
  body('metodoPagamento')
    .isIn(['dinheiro', 'cartao_debito', 'cartao_credito', 'pix', 'transferencia', 'boleto', 'cheque'])
    .withMessage('M√©todo de pagamento inv√°lido')
]

/**
 * GET /api/transactions
 * Listar todas as transa√ß√µes do usu√°rio
 */
router.get('/', (req, res) => {
  console.log('üìã [TRANSACTIONS] GET /transactions - userId:', req.userId)
  
  try {
    // Filtrar transa√ß√µes do usu√°rio logado
    const userTransactions = transactions.filter(t => t.userId === req.userId)
    
    // Calcular resumo
    const resumo = {
      totalReceitas: 0,
      totalDespesas: 0,
      saldo: 0,
      totalTransacoes: userTransactions.length
    }
    
    userTransactions.forEach(t => {
      if (t.tipo === 'receita') {
        resumo.totalReceitas += t.valor
      } else {
        resumo.totalDespesas += t.valor
      }
    })
    
    resumo.saldo = resumo.totalReceitas - resumo.totalDespesas
    
    console.log('‚úÖ [TRANSACTIONS] Retornando', userTransactions.length, 'transa√ß√µes')
    
    res.json({
      success: true,
      data: {
        transacoes: userTransactions,
        resumo,
        total: userTransactions.length
      }
    })
    
  } catch (error) {
    console.error('‚ùå [TRANSACTIONS] Erro ao buscar transa√ß√µes:', error)
    res.status(500).json({
      success: false,
      error: 'Erro interno do servidor'
    })
  }
})

/**
 * POST /api/transactions
 * Criar nova transa√ß√£o
 */
router.post('/', transactionValidation, (req, res) => {
  console.log('üíæ [TRANSACTIONS] POST /transactions - userId:', req.userId)
  console.log('üìù [TRANSACTIONS] Dados recebidos:', req.body)
  
  try {
    // Verificar erros de valida√ß√£o
    const errors = validationResult(req)
    if (!errors.isEmpty()) {
      console.log('‚ùå [TRANSACTIONS] Erros de valida√ß√£o:', errors.array())
      return res.status(400).json({
        success: false,
        error: 'Dados inv√°lidos',
        details: errors.array()
      })
    }

    // Criar nova transa√ß√£o
    const novaTransacao = {
      _id: (Date.now() + Math.random()).toString(),
      userId: req.userId,
      tipo: req.body.tipo,
      descricao: req.body.descricao.trim(),
      valor: parseFloat(req.body.valor),
      categoria: req.body.categoria,
      metodoPagamento: req.body.metodoPagamento,
      data: req.body.data ? new Date(req.body.data) : new Date(),
      observacoes: req.body.observacoes || '',
      orcamentoId: req.body.orcamentoId || '',
      tags: req.body.tags || [],
      recorrente: req.body.recorrente || {
        ativo: false,
        tipo: 'mensal',
        dataInicio: new Date(),
        dataFim: new Date(),
        intervalo: 1
      },
      criadoEm: new Date(),
      atualizadoEm: new Date()
    }

    // Adicionar √† lista
    transactions.push(novaTransacao)
    
    console.log('‚úÖ [TRANSACTIONS] Transa√ß√£o criada com ID:', novaTransacao._id)
    console.log('üìä [TRANSACTIONS] Total de transa√ß√µes:', transactions.length)

    res.status(201).json({
      success: true,
      message: 'Transa√ß√£o criada com sucesso',
      data: novaTransacao
    })

  } catch (error) {
    console.error('‚ùå [TRANSACTIONS] Erro ao criar transa√ß√£o:', error)
    res.status(500).json({
      success: false,
      error: 'Erro interno do servidor'
    })
  }
})

/**
 * GET /api/transactions/:id
 * Buscar transa√ß√£o por ID
 */
router.get('/:id', (req, res) => {
  console.log('üîç [TRANSACTIONS] GET /transactions/:id - ID:', req.params.id)
  
  try {
    const transacao = transactions.find(t => 
      t._id === req.params.id && t.userId === req.userId
    )

    if (!transacao) {
      return res.status(404).json({
        success: false,
        error: 'Transa√ß√£o n√£o encontrada'
      })
    }

    res.json({
      success: true,
      data: transacao
    })

  } catch (error) {
    console.error('‚ùå [TRANSACTIONS] Erro ao buscar transa√ß√£o:', error)
    res.status(500).json({
      success: false,
      error: 'Erro interno do servidor'
    })
  }
})

/**
 * PUT /api/transactions/:id
 * Atualizar transa√ß√£o
 */
router.put('/:id', transactionValidation, (req, res) => {
  console.log('‚úèÔ∏è [TRANSACTIONS] PUT /transactions/:id - ID:', req.params.id)
  
  try {
    // Verificar erros de valida√ß√£o
    const errors = validationResult(req)
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        error: 'Dados inv√°lidos',
        details: errors.array()
      })
    }

    const index = transactions.findIndex(t => 
      t._id === req.params.id && t.userId === req.userId
    )

    if (index === -1) {
      return res.status(404).json({
        success: false,
        error: 'Transa√ß√£o n√£o encontrada'
      })
    }

    // Atualizar transa√ß√£o
    transactions[index] = {
      ...transactions[index],
      tipo: req.body.tipo,
      descricao: req.body.descricao.trim(),
      valor: parseFloat(req.body.valor),
      categoria: req.body.categoria,
      metodoPagamento: req.body.metodoPagamento,
      data: req.body.data ? new Date(req.body.data) : transactions[index].data,
      observacoes: req.body.observacoes || '',
      orcamentoId: req.body.orcamentoId || '',
      tags: req.body.tags || [],
      recorrente: req.body.recorrente || transactions[index].recorrente,
      atualizadoEm: new Date()
    }

    console.log('‚úÖ [TRANSACTIONS] Transa√ß√£o atualizada')

    res.json({
      success: true,
      message: 'Transa√ß√£o atualizada com sucesso',
      data: transactions[index]
    })

  } catch (error) {
    console.error('‚ùå [TRANSACTIONS] Erro ao atualizar transa√ß√£o:', error)
    res.status(500).json({
      success: false,
      error: 'Erro interno do servidor'
    })
  }
})

/**
 * DELETE /api/transactions/:id
 * Excluir transa√ß√£o
 */
router.delete('/:id', (req, res) => {
  console.log('üóëÔ∏è [TRANSACTIONS] DELETE /transactions/:id - ID:', req.params.id)
  
  try {
    const index = transactions.findIndex(t => 
      t._id === req.params.id && t.userId === req.userId
    )

    if (index === -1) {
      return res.status(404).json({
        success: false,
        error: 'Transa√ß√£o n√£o encontrada'
      })
    }

    // Remover transa√ß√£o
    const transacaoRemovida = transactions.splice(index, 1)[0]
    
    console.log('‚úÖ [TRANSACTIONS] Transa√ß√£o removida')

    res.json({
      success: true,
      message: 'Transa√ß√£o removida com sucesso',
      data: transacaoRemovida
    })

  } catch (error) {
    console.error('‚ùå [TRANSACTIONS] Erro ao remover transa√ß√£o:', error)
    res.status(500).json({
      success: false,
      error: 'Erro interno do servidor'
    })
  }
})

// Rota de teste
router.get('/test/debug', (req, res) => {
  res.json({
    message: 'Sistema de transa√ß√µes mockado funcionando!',
    userId: req.userId,
    totalTransactions: transactions.length,
    userTransactions: transactions.filter(t => t.userId === req.userId).length,
    totalUsers: mockUsers.length,
    endpoints: [
      'GET /api/transactions',
      'POST /api/transactions',
      'GET /api/transactions/:id',
      'PUT /api/transactions/:id',
      'DELETE /api/transactions/:id'
    ]
  })
})

module.exports = router